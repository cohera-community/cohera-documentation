---
title: Architecture
description: Understanding Cohera's modular architecture and how frontend, backend, and database layers work together
---

import { Code, Steps, FileTree } from "@astrojs/starlight/components";

import postSchemaCode from "../../../examples/architecture/database/posts_schema.ts?raw";
import installModulesCode from "../../../examples/architecture/integration/install-modules.sh?raw";
import dbCode from "../../../examples/architecture/integration/schema.ts?raw";
import trpcCode from "../../../examples/architecture/integration/trpc.ts?raw";
import loadCode from "../../../examples/architecture/integration/load.ts?raw";
import frontendCode from "../../../examples/architecture/integration/frontend.svelte?raw";

Cohera is designed as a library of loosely coupled [modules](/reference/modules) that developers compose to build community platforms. Each module bundles its frontend, backend, and data layers while maintaining independence between these layers.

:::note
For quick reference definitions of key terms used throughout this document, see [Core Concepts](/explanation/concepts/).
:::

## Design Principles

- **Loosely coupled**: Each module exposes clean APIs for independent use
- **Independent layers**: Use just the backend, just the UI, or the complete module
- **Fully featured**: Modules provide everything for the most common use case
- **Coherently integrated**: Modules integrate with each other
- **Type safety**: End-to-end type safety
- **Monolithic deployment**: Optimized for simple deployment
- **Fine-tuned DX**: We take care to make the experience delightful for developers
- **Automation, not magic**: Everything is transparently set up and easy to reason about
- **Imperative Shell, Functional Core**: Every module cleanly separates logic from side-effects
- **Federation ready**: Optional ActivityPub federation via core layer

## Technology Stack

We built on these awesome technologies:

- **Frontend**: SvelteKit & `shadcn-svelte`
- **Backend**: tRPC (or [experimental remote functions](https://svelte.dev/docs/kit/remote-functions)?)
- **Database**: PostgreSQL via Drizzle ORM
- **Type Safety**: TypeScript via tRPC & drizzle
- **Federation**: fedify (optional)
- **Mobile**: Capacitor (optional)

## Integration Example

Here's how developers build a platform with Cohera:

<Steps>

1. Install Modules

   <Code code={installModulesCode} lang="bash" title="add modules" />

2. Setup [Backend](#backend-layer) and [Database](#database-layer)

   ```bash title='run migrations'
   cohera db migrate
   ```

   These file changes are done automatically for you when using the `cohera` cli.

   <Code
     code={dbCode}
     ins={[1, 2]}
     lang="typescript"
     title="src/lib/server/db/schema.ts"
   />

   :::note
   We could also create one file per module, e.g. `schema/posts.ts` and `schema/events.ts` instead.
   :::

   <Code
     code={trpcCode}
     ins={[1, 2, 5, 6]}
     lang="typescript"
     title="src/lib/server/trpc.ts"
   />

3. Use in [Frontend](#frontend-layer)

   :::note
   Should routes be auto created / included in modules?
   :::

   <Code code={loadCode} lang="typescript" title="routes/+page.ts" />
   <Code code={frontendCode} lang="svelte" title="routes/+page.svelte" />

4. Deploy

   ```bash title='deploy'
   cohera deploy
   ```

</Steps>

## Package Structure

Each Cohera module is a single npm package with structured exports:

<FileTree>

- @cohera/posts/
  - [api](#backend-layer) tRPC routers and procedures (backend)
  - [ui](#frontend-layer) Svelte components (frontend)
  - [db](#database-layer) Drizzle schemas and migrations (data)
  - types Shared TypeScript types

</FileTree>

### Example Usage

```typescript
// Backend: Add router to your tRPC app
import { postsRouter } from "@cohera/posts/api";

// Frontend: Use Svelte components
import { PostCard, PostList } from "@cohera/posts/ui";

// Database: Access table schemas
import { posts } from "@cohera/posts/db";

// Types: Import type definitions
import type { Post, NewPost } from "@cohera/posts/types";
```

This structure provides:

- **Single version** per module
- **Tree-shakeable**
- **Clear separation**
- **Independence**

## Backend Layer

The backend layer consists of tRPC routers that handle business logic and data access.

### Router Structure

```typescript
export const postsRouter = t.router({
  list: t.procedure
    .input(z.object({ limit: z.number().optional() }))
    .query(async ({ input, ctx }) => {
      return ctx.db
        .select()
        .from(posts)
        .limit(input.limit ?? 10);
    }),

  create: t.procedure
    .input(z.object({ title: z.string(), content: z.string() }))
    .mutation(async ({ input, ctx }) => {
      const post = await ctx.db.insert(posts).values(input).returning();
      await ctx.federation?.announce(post);
      return post;
    }),
});
```

### Key Characteristics

- Each module provides its own tRPC router
- Routers compose into your main app's router
- Database access via Drizzle ORM (Postgres)
- Context includes `db` instance and optional `federation` service
- Types automatically inferred for frontend use

### Independence

You can use module routers in several ways:

- Import complete router in your tRPC app
- Use only specific procedures you need
- Build custom backend implementing the same type contracts

## Frontend Layer

:::caution[Automatic routes/pages?]
Should routes be part of the modules and/or be created by the CLI?
:::

The frontend layer provides Svelte components for SvelteKit applications.

### Component Design

:::note
Real components of course are more complex, feature-complete and better styled.
:::

```svelte
<script lang="ts">
  import type { Post } from "@cohera/posts/types";
  import * as Card from "$lib/components/ui/card/index.js";
  import { Button } from "$lib/components/ui/button/index.js";

  interface Props {
    post: Post;
    onDelete?: (id: Post["id"]) => void;
  }

  const { post, onDelete }: Props = $props();
</script>

<Card.Root>
  <Card.Header><Card.Title>{post.title}</Card.Title></Card.Header>
  <Card.Content>
    <p>{post.content}</p>
  </Card.Content>
  {#if onDelete}
    <Button variant="destructive" onclick={() => onDelete(post.id)}>
      Delete
    </Button>
  {/if}
</Card.Root>
```

### Key Characteristics

- Components are presentation-focused (data passed as props)
- Don't directly call tRPC - parent handles data fetching
- Type-safe props using shared types from `/types` export
- Tailwind allows [theming](guides/theming)
- Work with any backend matching the type contract

## Database Layer

The database layer provides Drizzle schemas for PostgreSQL.

:::note
Alternatives to consider might be [prisma](https://www.prisma.io/), [kysley](https://kysely.dev/) or other ORMs.
:::

### Schema Example

<Code
  code={postSchemaCode}
  title="@cohera/posts/db/schema.ts"
  lang="typescript"
/>

### Key Characteristics

- Each module exports Drizzle table schemas
- Schemas include optional federation fields
- Types inferred from schemas
- Migrations bundled with modules
- Single Postgres instance contains all module tables

## Federation Layer

The `@cohera/federation` package provides ActivityPub integration.

### Federation Service

uses [fedify](https://fedify.dev/)

### Key Characteristics

- Single federation package shared by all modules
- Modules register handlers for their activity types
- Federation is optional (enabled via configuration)
- Handles ActivityPub protocol details (signing, delivery, inbox processing)

### Module Integration

```typescript
create: t.procedure
  .input(z.object({ title: z.string(), content: z.string() }))
  .mutation(async ({ input, ctx }) => {
    const post = await ctx.db.insert(posts).values(input).returning();

    await ctx.federation?.announce({
      type: "Create",
      object: { type: "Note", ...post },
    });

    return post;
  });
```
