---
title: Architecture
description: Understanding Cohera's modular architecture and how frontend, backend, and database layers work together
---

import { Code, Steps, FileTree } from "@astrojs/starlight/components";

import postSchemaCode from "../../../examples/architecture/database/posts_schema.ts?raw";
import installModulesCode from "../../../examples/architecture/integration/install-modules.sh?raw";
import dbCode from "../../../examples/architecture/integration/db.ts?raw";
import trpcCode from "../../../examples/architecture/integration/trpc.ts?raw";
import frontendCode from "../../../examples/architecture/integration/frontend.svelte?raw";

Cohera is designed as a library of loosely coupled [modules](/reference/modules) that developers compose to build community platforms. Each module bundles its frontend, backend, and data layers while maintaining independence between these layers.

:::note
For quick reference definitions of key terms used throughout this document, see [Core Concepts](/explanation/concepts/).
:::

## Design Principles

- **Loosely coupled**: Each module exposes clean APIs for independent use
- **Fully featured**: Modules provide everything for the most common use case
- **Independent layers**: Use just the backend, just the UI, or the complete module
- **Coherently integrated**: Modules integrate with each other
- **Type safety**: End-to-end type safety via tRPC
- **Monolithic deployment**: Optimized for simple deployment at community scale
- **Federation ready**: Optional ActivityPub federation via core layer
- **Fine-tuned DX**: We take care to make the experience delightful for developers
- **Automation, not magic**: Everything is transparently set up and easy to reason about
- **Imperative Shell, Functional Core**: Every module cleanly separates logic from side-effects

## Technology Stack

- **Frontend**: SvelteKit
- **Backend**: tRPC
- **Database**: PostgreSQL via Drizzle ORM
- **Type Safety**: TypeScript with tRPC inference
- **Federation**: ActivityPub (optional)
- **Mobile**: Capacitor

## Integration Example

Here's how developers build a platform with Cohera:

<Steps>

1. Install Modules

   <Code code={installModulesCode} lang="bash" title="add modules" />

2. Setup [Backend](#backend-layer) and [Database](#database-layer)

   ```bash title='run migrations'
   cohera db migrate
   ```

   These file changes are done automatically for you when using the `cohera` cli.

   <Code
     code={dbCode}
     ins={[2, 3, "{ posts, events }"]}
     lang="typescript"
     title="src/lib/server/db.ts"
   />

   <Code
     code={trpcCode}
     ins={[1, 2, 5, 6]}
     lang="typescript"
     title="src/lib/server/trpc.ts"
   />

3. Use in [Frontend](#frontend-layer)

   <Code code={frontendCode} lang="svelte" title="routes/posts/+page.svelte" />

4. Deploy

   ```bash title='deploy'
   cohera deploy
   ```

</Steps>

## Package Structure

Each Cohera module is a single npm package with structured exports:

<FileTree>

- @cohera/posts/
  - [api](#backend-layer) tRPC routers and procedures (backend)
  - [ui](#frontend-layer) Svelte components (frontend)
  - [db](#database-layer) Drizzle schemas and migrations (data)
  - types Shared TypeScript types

</FileTree>

### Example Usage

```typescript
// Backend: Add router to your tRPC app
import { postsRouter } from "@cohera/posts/api";

// Frontend: Use Svelte components
import { PostCard, PostList } from "@cohera/posts/ui";

// Database: Access table schemas
import { posts } from "@cohera/posts/db";

// Types: Import type definitions
import type { Post, NewPost } from "@cohera/posts/types";
```

This structure provides:

- **Single version** per module
- **Tree-shakeable**
- **Clear separation**
- **Independence**

## Backend Layer

The backend layer consists of tRPC routers that handle business logic and data access.

### Router Structure

```typescript
export const postsRouter = t.router({
  list: t.procedure
    .input(z.object({ limit: z.number().optional() }))
    .query(async ({ input, ctx }) => {
      return ctx.db
        .select()
        .from(posts)
        .limit(input.limit ?? 10);
    }),

  create: t.procedure
    .input(z.object({ title: z.string(), content: z.string() }))
    .mutation(async ({ input, ctx }) => {
      const post = await ctx.db.insert(posts).values(input).returning();
      await ctx.federation?.announce(post);
      return post;
    }),
});
```

### Key Characteristics

- Each module provides its own tRPC router
- Routers compose into your main app's router
- Database access via Drizzle ORM (Postgres)
- Context includes `db` instance and optional `federation` service
- Types automatically inferred for frontend use

### Independence

You can use module routers in several ways:

- Import complete router in your tRPC app
- Use only specific procedures you need
- Skip Cohera's backend entirely and use just the UI components
- Build custom backend implementing the same type contracts

## Frontend Layer

:::caution[Automatic routes/pages?]
Should routes be part of the modules and/or be created by the CLI?
:::

The frontend layer provides Svelte components for SvelteKit applications.

### Component Design

```svelte
<script lang="ts">
  import type { Post } from "@cohera/posts/types";

  export let post: Post;
  export let onDelete: ((id: string) => void) | undefined = undefined;
</script>

<article class="post-card">
  <h3>{post.title}</h3>
  <p>{post.content}</p>
  {#if onDelete}
    <button on:click={() => onDelete(post.id)}>Delete</button>
  {/if}
</article>

<style>
  .post-card {
    border: 1px solid var(--cohera-border-color, #ccc);
    padding: var(--cohera-spacing, 1rem);
  }
</style>
```

### Key Characteristics

- Components are presentation-focused (data passed as props)
- Don't directly call tRPC - parent handles data fetching
- Type-safe props using shared types from `/types` export
- CSS variables enable theming and customization
- Work with any backend matching the type contract

### Using in SvelteKit

```svelte
<script lang="ts">
  import { PostCard } from "@cohera/posts/ui";
  import { trpc } from "$lib/trpc";

  const posts = trpc.posts.list.query({ limit: 10 });
</script>

{#each $posts.data ?? [] as post}
  <PostCard {post} />
{/each}
```

## Database Layer

The database layer provides Drizzle schemas for PostgreSQL.

### Schema Example

<Code
  code={postSchemaCode}
  title="@cohera/posts/db/schema.ts"
  lang="typescript"
/>

### Key Characteristics

- Each module exports Drizzle table schemas
- Schemas include optional federation fields
- Types inferred from schemas
- Migrations bundled with modules
- Single Postgres instance contains all module tables

### Database Setup

```typescript
import { drizzle } from "drizzle-orm/postgres-js";
import { posts } from "@cohera/posts/db";
import { events } from "@cohera/events/db";
import { profiles } from "@cohera/profiles/db";

export const db = drizzle(postgres(DATABASE_URL), {
  schema: { posts, events, profiles },
});
```

## Federation Layer

The `@cohera/federation` package provides ActivityPub integration.

### Federation Service

```typescript
export class FederationService {
  constructor(private config: FederationConfig) {}

  async announce(activity: Activity): Promise<void> {
    if (!this.config.enabled) return;

    const apActivity = this.toActivityPub(activity);
    await this.deliverToInboxes(apActivity);
  }

  async handleInbox(activity: ActivityPubActivity): Promise<void> {
    // Validate and route to module handlers
  }
}
```

### Key Characteristics

- Single federation package shared by all modules
- Modules register handlers for their activity types
- Federation is optional (enabled via configuration)
- Handles ActivityPub protocol details (signing, delivery, inbox processing)

### Module Integration

```typescript
create: t.procedure
  .input(z.object({ title: z.string(), content: z.string() }))
  .mutation(async ({ input, ctx }) => {
    const post = await ctx.db.insert(posts).values(input).returning();

    await ctx.federation?.announce({
      type: "Create",
      object: { type: "Note", ...post },
    });

    return post;
  });
```
